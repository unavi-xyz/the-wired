package wired:gltf;

world lib {
  export node;
  export mesh;
}

interface node {
  use mesh.{mesh};
  use wired:math/types.{vec3, vec4};

  record transform {
    translation: vec3,
    rotation: vec4,
    scale: vec3,
  }

  resource node {
    id: func() -> u32;

    transform: func() -> transform;
    set-transform: func(transform: transform);

    mesh: func() -> option<mesh>;
    set-mesh: func(mesh: option<mesh>);
  }

  nodes: func() -> list<node>;
  create-node: func() -> node;
  remove-node: func(id: u32);
}

interface material {
  use wired:math/types.{vec4};

  resource material {
    id: func() -> u32;

    color: func() -> vec4;
    set-color: func(value: vec4);
  }

  materials: func() -> list<material>;
  create-material: func() -> material;
  remove-material: func(id: u32);
}

interface mesh {
  use material.{material};

  resource primitive {
    id: func() -> u32;

    indices: func() -> list<u32>;
    set-indices: func(value: list<u32>);

    material: func() -> material;
    set-material: func(value: material);

    normals: func() -> list<f32>;
    set-normals: func(value: list<f32>);

    positions: func() -> list<f32>;
    set-positions: func(value: list<f32>);

    uvs: func() -> list<f32>;
    set-uvs: func(value: list<f32>);
  }

  resource mesh {
    id: func() -> u32;

    name: func() -> string;
    set-name: func(name: string);

    primitives: func() -> list<primitive>;
    create-primitive: func() -> primitive;
    remove-primitive: func(id: u32);
  }

  meshes: func() -> list<mesh>;
  create-mesh: func() -> mesh;
  remove-mesh: func(id: u32);
}
