// @generated by protobuf-ts 2.9.0
// @generated from protobuf file "websocket/webrtc/request.proto" (package "com.wiredprotocol.websocket.webrtc.request", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { SctpStreamParameters } from "./signaling";
import { RtpParameters } from "./signaling";
import { RtpCapabilities } from "./signaling";
import { DtlsParameters } from "./signaling";
/**
 * @generated from protobuf message com.wiredprotocol.websocket.webrtc.request.AudioPause
 */
export interface AudioPause {
    /**
     * @generated from protobuf field: bool pause = 1;
     */
    pause: boolean;
}
/**
 * @generated from protobuf message com.wiredprotocol.websocket.webrtc.request.TransportConnect
 */
export interface TransportConnect {
    /**
     * @generated from protobuf field: com.wiredprotocol.websocket.webrtc.request.TransportType type = 1;
     */
    type: TransportType;
    /**
     * @generated from protobuf field: com.wiredprotocol.websocket.webrtc.signaling.DtlsParameters dtlsParameters = 2;
     */
    dtlsParameters?: DtlsParameters;
}
/**
 * @generated from protobuf message com.wiredprotocol.websocket.webrtc.request.TransportCreate
 */
export interface TransportCreate {
    /**
     * @generated from protobuf field: com.wiredprotocol.websocket.webrtc.request.TransportType type = 1;
     */
    type: TransportType;
}
/**
 * @generated from protobuf message com.wiredprotocol.websocket.webrtc.request.GetRouterRtpCapabilities
 */
export interface GetRouterRtpCapabilities {
}
/**
 * @generated from protobuf message com.wiredprotocol.websocket.webrtc.request.SetRtpCapabilities
 */
export interface SetRtpCapabilities {
    /**
     * @generated from protobuf field: com.wiredprotocol.websocket.webrtc.signaling.RtpCapabilities rtpCapabilities = 1;
     */
    rtpCapabilities?: RtpCapabilities;
}
/**
 * @generated from protobuf message com.wiredprotocol.websocket.webrtc.request.Produce
 */
export interface Produce {
    /**
     * @generated from protobuf field: com.wiredprotocol.websocket.webrtc.signaling.RtpParameters rtpParameters = 1;
     */
    rtpParameters?: RtpParameters;
}
/**
 * @generated from protobuf message com.wiredprotocol.websocket.webrtc.request.ProduceData
 */
export interface ProduceData {
    /**
     * @generated from protobuf field: com.wiredprotocol.websocket.webrtc.signaling.SctpStreamParameters sctpStreamParameters = 1;
     */
    sctpStreamParameters?: SctpStreamParameters;
}
/**
 * @generated from protobuf enum com.wiredprotocol.websocket.webrtc.request.TransportType
 */
export enum TransportType {
    /**
     * @generated from protobuf enum value: CONSUMER = 0;
     */
    CONSUMER = 0,
    /**
     * @generated from protobuf enum value: PRODUCER = 1;
     */
    PRODUCER = 1
}
// @generated message type with reflection information, may provide speed optimized methods
class AudioPause$Type extends MessageType<AudioPause> {
    constructor() {
        super("com.wiredprotocol.websocket.webrtc.request.AudioPause", [
            { no: 1, name: "pause", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<AudioPause>): AudioPause {
        const message = { pause: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AudioPause>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AudioPause): AudioPause {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool pause */ 1:
                    message.pause = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AudioPause, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool pause = 1; */
        if (message.pause !== false)
            writer.tag(1, WireType.Varint).bool(message.pause);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.wiredprotocol.websocket.webrtc.request.AudioPause
 */
export const AudioPause = new AudioPause$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TransportConnect$Type extends MessageType<TransportConnect> {
    constructor() {
        super("com.wiredprotocol.websocket.webrtc.request.TransportConnect", [
            { no: 1, name: "type", kind: "enum", T: () => ["com.wiredprotocol.websocket.webrtc.request.TransportType", TransportType] },
            { no: 2, name: "dtlsParameters", kind: "message", T: () => DtlsParameters }
        ]);
    }
    create(value?: PartialMessage<TransportConnect>): TransportConnect {
        const message = { type: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TransportConnect>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TransportConnect): TransportConnect {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* com.wiredprotocol.websocket.webrtc.request.TransportType type */ 1:
                    message.type = reader.int32();
                    break;
                case /* com.wiredprotocol.websocket.webrtc.signaling.DtlsParameters dtlsParameters */ 2:
                    message.dtlsParameters = DtlsParameters.internalBinaryRead(reader, reader.uint32(), options, message.dtlsParameters);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TransportConnect, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* com.wiredprotocol.websocket.webrtc.request.TransportType type = 1; */
        if (message.type !== 0)
            writer.tag(1, WireType.Varint).int32(message.type);
        /* com.wiredprotocol.websocket.webrtc.signaling.DtlsParameters dtlsParameters = 2; */
        if (message.dtlsParameters)
            DtlsParameters.internalBinaryWrite(message.dtlsParameters, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.wiredprotocol.websocket.webrtc.request.TransportConnect
 */
export const TransportConnect = new TransportConnect$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TransportCreate$Type extends MessageType<TransportCreate> {
    constructor() {
        super("com.wiredprotocol.websocket.webrtc.request.TransportCreate", [
            { no: 1, name: "type", kind: "enum", T: () => ["com.wiredprotocol.websocket.webrtc.request.TransportType", TransportType] }
        ]);
    }
    create(value?: PartialMessage<TransportCreate>): TransportCreate {
        const message = { type: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TransportCreate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TransportCreate): TransportCreate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* com.wiredprotocol.websocket.webrtc.request.TransportType type */ 1:
                    message.type = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TransportCreate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* com.wiredprotocol.websocket.webrtc.request.TransportType type = 1; */
        if (message.type !== 0)
            writer.tag(1, WireType.Varint).int32(message.type);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.wiredprotocol.websocket.webrtc.request.TransportCreate
 */
export const TransportCreate = new TransportCreate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetRouterRtpCapabilities$Type extends MessageType<GetRouterRtpCapabilities> {
    constructor() {
        super("com.wiredprotocol.websocket.webrtc.request.GetRouterRtpCapabilities", []);
    }
    create(value?: PartialMessage<GetRouterRtpCapabilities>): GetRouterRtpCapabilities {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetRouterRtpCapabilities>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetRouterRtpCapabilities): GetRouterRtpCapabilities {
        return target ?? this.create();
    }
    internalBinaryWrite(message: GetRouterRtpCapabilities, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.wiredprotocol.websocket.webrtc.request.GetRouterRtpCapabilities
 */
export const GetRouterRtpCapabilities = new GetRouterRtpCapabilities$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetRtpCapabilities$Type extends MessageType<SetRtpCapabilities> {
    constructor() {
        super("com.wiredprotocol.websocket.webrtc.request.SetRtpCapabilities", [
            { no: 1, name: "rtpCapabilities", kind: "message", T: () => RtpCapabilities }
        ]);
    }
    create(value?: PartialMessage<SetRtpCapabilities>): SetRtpCapabilities {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SetRtpCapabilities>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetRtpCapabilities): SetRtpCapabilities {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* com.wiredprotocol.websocket.webrtc.signaling.RtpCapabilities rtpCapabilities */ 1:
                    message.rtpCapabilities = RtpCapabilities.internalBinaryRead(reader, reader.uint32(), options, message.rtpCapabilities);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetRtpCapabilities, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* com.wiredprotocol.websocket.webrtc.signaling.RtpCapabilities rtpCapabilities = 1; */
        if (message.rtpCapabilities)
            RtpCapabilities.internalBinaryWrite(message.rtpCapabilities, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.wiredprotocol.websocket.webrtc.request.SetRtpCapabilities
 */
export const SetRtpCapabilities = new SetRtpCapabilities$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Produce$Type extends MessageType<Produce> {
    constructor() {
        super("com.wiredprotocol.websocket.webrtc.request.Produce", [
            { no: 1, name: "rtpParameters", kind: "message", T: () => RtpParameters }
        ]);
    }
    create(value?: PartialMessage<Produce>): Produce {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Produce>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Produce): Produce {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* com.wiredprotocol.websocket.webrtc.signaling.RtpParameters rtpParameters */ 1:
                    message.rtpParameters = RtpParameters.internalBinaryRead(reader, reader.uint32(), options, message.rtpParameters);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Produce, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* com.wiredprotocol.websocket.webrtc.signaling.RtpParameters rtpParameters = 1; */
        if (message.rtpParameters)
            RtpParameters.internalBinaryWrite(message.rtpParameters, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.wiredprotocol.websocket.webrtc.request.Produce
 */
export const Produce = new Produce$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ProduceData$Type extends MessageType<ProduceData> {
    constructor() {
        super("com.wiredprotocol.websocket.webrtc.request.ProduceData", [
            { no: 1, name: "sctpStreamParameters", kind: "message", T: () => SctpStreamParameters }
        ]);
    }
    create(value?: PartialMessage<ProduceData>): ProduceData {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ProduceData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ProduceData): ProduceData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* com.wiredprotocol.websocket.webrtc.signaling.SctpStreamParameters sctpStreamParameters */ 1:
                    message.sctpStreamParameters = SctpStreamParameters.internalBinaryRead(reader, reader.uint32(), options, message.sctpStreamParameters);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ProduceData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* com.wiredprotocol.websocket.webrtc.signaling.SctpStreamParameters sctpStreamParameters = 1; */
        if (message.sctpStreamParameters)
            SctpStreamParameters.internalBinaryWrite(message.sctpStreamParameters, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.wiredprotocol.websocket.webrtc.request.ProduceData
 */
export const ProduceData = new ProduceData$Type();
