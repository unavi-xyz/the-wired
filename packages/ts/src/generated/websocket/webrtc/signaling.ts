// @generated by protobuf-ts 2.9.0
// @generated from protobuf file "websocket/webrtc/signaling.proto" (package "com.wiredprotocol.websocket.webrtc.signaling", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * @generated from protobuf message com.wiredprotocol.websocket.webrtc.signaling.DtlsParameters
 */
export interface DtlsParameters {
    /**
     * @generated from protobuf field: com.wiredprotocol.websocket.webrtc.signaling.DtlsParameters.Role role = 1;
     */
    role: DtlsParameters_Role;
    /**
     * @generated from protobuf field: repeated com.wiredprotocol.websocket.webrtc.signaling.DtlsParameters.Fingerprint fingerprints = 2;
     */
    fingerprints: DtlsParameters_Fingerprint[];
}
/**
 * @generated from protobuf message com.wiredprotocol.websocket.webrtc.signaling.DtlsParameters.Fingerprint
 */
export interface DtlsParameters_Fingerprint {
    /**
     * @generated from protobuf field: string algorithm = 1;
     */
    algorithm: string;
    /**
     * @generated from protobuf field: string value = 2;
     */
    value: string;
}
/**
 * @generated from protobuf enum com.wiredprotocol.websocket.webrtc.signaling.DtlsParameters.Role
 */
export enum DtlsParameters_Role {
    /**
     * @generated from protobuf enum value: AUTO = 0;
     */
    AUTO = 0,
    /**
     * @generated from protobuf enum value: CLIENT = 1;
     */
    CLIENT = 1,
    /**
     * @generated from protobuf enum value: SERVER = 2;
     */
    SERVER = 2
}
/**
 * @generated from protobuf message com.wiredprotocol.websocket.webrtc.signaling.IceCandidate
 */
export interface IceCandidate {
    /**
     * @generated from protobuf field: string foundation = 1;
     */
    foundation: string;
    /**
     * @generated from protobuf field: int32 priority = 2;
     */
    priority: number;
    /**
     * @generated from protobuf field: string ip = 3;
     */
    ip: string;
    /**
     * @generated from protobuf field: int32 port = 4;
     */
    port: number;
    /**
     * @generated from protobuf field: com.wiredprotocol.websocket.webrtc.signaling.IceCandidate.Protocol protocol = 5;
     */
    protocol: IceCandidate_Protocol;
    /**
     * @generated from protobuf field: com.wiredprotocol.websocket.webrtc.signaling.IceCandidate.Type type = 6;
     */
    type: IceCandidate_Type;
    /**
     * @generated from protobuf field: optional com.wiredprotocol.websocket.webrtc.signaling.IceCandidate.TcpType tcp_type = 7;
     */
    tcpType?: IceCandidate_TcpType;
}
/**
 * @generated from protobuf enum com.wiredprotocol.websocket.webrtc.signaling.IceCandidate.Protocol
 */
export enum IceCandidate_Protocol {
    /**
     * @generated from protobuf enum value: UDP = 0;
     */
    UDP = 0,
    /**
     * @generated from protobuf enum value: TCP = 1;
     */
    TCP = 1
}
/**
 * @generated from protobuf enum com.wiredprotocol.websocket.webrtc.signaling.IceCandidate.Type
 */
export enum IceCandidate_Type {
    /**
     * @generated from protobuf enum value: HOST = 0;
     */
    HOST = 0,
    /**
     * @generated from protobuf enum value: SRFLX = 1;
     */
    SRFLX = 1,
    /**
     * @generated from protobuf enum value: PRFLX = 2;
     */
    PRFLX = 2,
    /**
     * @generated from protobuf enum value: RELAY = 3;
     */
    RELAY = 3
}
/**
 * @generated from protobuf enum com.wiredprotocol.websocket.webrtc.signaling.IceCandidate.TcpType
 */
export enum IceCandidate_TcpType {
    /**
     * @generated from protobuf enum value: ACTIVE = 0;
     */
    ACTIVE = 0,
    /**
     * @generated from protobuf enum value: PASSIVE = 1;
     */
    PASSIVE = 1,
    /**
     * @generated from protobuf enum value: SO = 2;
     */
    SO = 2
}
/**
 * @generated from protobuf message com.wiredprotocol.websocket.webrtc.signaling.RtpCapabilities
 */
export interface RtpCapabilities {
    /**
     * @generated from protobuf field: repeated com.wiredprotocol.websocket.webrtc.signaling.RtpCapabilities.Codec codecs = 1;
     */
    codecs: RtpCapabilities_Codec[];
    /**
     * @generated from protobuf field: repeated com.wiredprotocol.websocket.webrtc.signaling.RtpCapabilities.HeaderExtension header_extensions = 2;
     */
    headerExtensions: RtpCapabilities_HeaderExtension[];
}
/**
 * @generated from protobuf message com.wiredprotocol.websocket.webrtc.signaling.RtpCapabilities.Codec
 */
export interface RtpCapabilities_Codec {
    /**
     * @generated from protobuf field: com.wiredprotocol.websocket.webrtc.signaling.RtpCapabilities.Kind kind = 1;
     */
    kind: RtpCapabilities_Kind;
    /**
     * @generated from protobuf field: string mime_type = 2;
     */
    mimeType: string;
    /**
     * @generated from protobuf field: int32 clock_rate = 3;
     */
    clockRate: number;
    /**
     * @generated from protobuf field: optional int32 channels = 4;
     */
    channels?: number;
    /**
     * @generated from protobuf field: repeated com.wiredprotocol.websocket.webrtc.signaling.RtpCapabilities.Codec.RtcpFeedback rtcp_feedback = 5;
     */
    rtcpFeedback: RtpCapabilities_Codec_RtcpFeedback[];
}
/**
 * @generated from protobuf message com.wiredprotocol.websocket.webrtc.signaling.RtpCapabilities.Codec.RtcpFeedback
 */
export interface RtpCapabilities_Codec_RtcpFeedback {
    /**
     * @generated from protobuf field: string type = 1;
     */
    type: string;
    /**
     * @generated from protobuf field: optional string parameter = 2;
     */
    parameter?: string;
}
/**
 * @generated from protobuf message com.wiredprotocol.websocket.webrtc.signaling.RtpCapabilities.HeaderExtension
 */
export interface RtpCapabilities_HeaderExtension {
    /**
     * @generated from protobuf field: string uri = 1;
     */
    uri: string;
    /**
     * @generated from protobuf field: com.wiredprotocol.websocket.webrtc.signaling.RtpCapabilities.Kind kind = 2;
     */
    kind: RtpCapabilities_Kind;
    /**
     * @generated from protobuf field: int32 preferred_id = 3;
     */
    preferredId: number;
    /**
     * @generated from protobuf field: optional bool preferred_encrypt = 4;
     */
    preferredEncrypt?: boolean;
    /**
     * @generated from protobuf field: optional com.wiredprotocol.websocket.webrtc.signaling.RtpCapabilities.HeaderExtension.Direction direction = 5;
     */
    direction?: RtpCapabilities_HeaderExtension_Direction;
}
/**
 * @generated from protobuf enum com.wiredprotocol.websocket.webrtc.signaling.RtpCapabilities.HeaderExtension.Direction
 */
export enum RtpCapabilities_HeaderExtension_Direction {
    /**
     * @generated from protobuf enum value: SENDRECV = 0;
     */
    SENDRECV = 0,
    /**
     * @generated from protobuf enum value: SENDONLY = 1;
     */
    SENDONLY = 1,
    /**
     * @generated from protobuf enum value: RECVONLY = 2;
     */
    RECVONLY = 2,
    /**
     * @generated from protobuf enum value: INACTIVE = 3;
     */
    INACTIVE = 3
}
/**
 * @generated from protobuf enum com.wiredprotocol.websocket.webrtc.signaling.RtpCapabilities.Kind
 */
export enum RtpCapabilities_Kind {
    /**
     * @generated from protobuf enum value: AUDIO = 0;
     */
    AUDIO = 0,
    /**
     * @generated from protobuf enum value: VIDEO = 1;
     */
    VIDEO = 1
}
/**
 * @generated from protobuf message com.wiredprotocol.websocket.webrtc.signaling.RtpParameters
 */
export interface RtpParameters {
    /**
     * @generated from protobuf field: repeated com.wiredprotocol.websocket.webrtc.signaling.RtpParameters.Codec codecs = 1;
     */
    codecs: RtpParameters_Codec[];
    /**
     * @generated from protobuf field: repeated com.wiredprotocol.websocket.webrtc.signaling.RtpParameters.HeaderExtension header_extensions = 2;
     */
    headerExtensions: RtpParameters_HeaderExtension[];
}
/**
 * @generated from protobuf message com.wiredprotocol.websocket.webrtc.signaling.RtpParameters.Codec
 */
export interface RtpParameters_Codec {
    /**
     * @generated from protobuf field: string mime_type = 1;
     */
    mimeType: string;
    /**
     * @generated from protobuf field: int32 payload_type = 2;
     */
    payloadType: number;
    /**
     * @generated from protobuf field: int32 clock_rate = 3;
     */
    clockRate: number;
    /**
     * @generated from protobuf field: optional int32 channels = 4;
     */
    channels?: number;
}
/**
 * @generated from protobuf message com.wiredprotocol.websocket.webrtc.signaling.RtpParameters.HeaderExtension
 */
export interface RtpParameters_HeaderExtension {
    /**
     * @generated from protobuf field: string uri = 1;
     */
    uri: string;
    /**
     * @generated from protobuf field: int32 id = 2;
     */
    id: number;
}
/**
 * @generated from protobuf message com.wiredprotocol.websocket.webrtc.signaling.SctpParameters
 */
export interface SctpParameters {
    /**
     * @generated from protobuf field: int32 port = 1;
     */
    port: number;
    /**
     * @generated from protobuf field: optional int32 max_message_size = 2;
     */
    maxMessageSize?: number;
    /**
     * @generated from protobuf field: optional int32 max_retransmits = 3;
     */
    maxRetransmits?: number;
    /**
     * @generated from protobuf field: optional bool negotiated = 4;
     */
    negotiated?: boolean;
    /**
     * @generated from protobuf field: optional bool stream_reset = 5;
     */
    streamReset?: boolean;
    /**
     * @generated from protobuf field: optional com.wiredprotocol.websocket.webrtc.signaling.SctpParameters.PartialReliability partial_reliability = 6;
     */
    partialReliability?: SctpParameters_PartialReliability;
}
/**
 * @generated from protobuf message com.wiredprotocol.websocket.webrtc.signaling.SctpParameters.PartialReliability
 */
export interface SctpParameters_PartialReliability {
    /**
     * @generated from protobuf field: optional bool allowed = 1;
     */
    allowed?: boolean;
    /**
     * @generated from protobuf field: optional int32 max_retransmits = 2;
     */
    maxRetransmits?: number;
    /**
     * @generated from protobuf field: optional int32 max_packet_life_time = 3;
     */
    maxPacketLifeTime?: number;
}
/**
 * @generated from protobuf message com.wiredprotocol.websocket.webrtc.signaling.SctpStreamParameters
 */
export interface SctpStreamParameters {
    /**
     * @generated from protobuf field: int32 stream_id = 1;
     */
    streamId: number;
    /**
     * @generated from protobuf field: optional bool ordered = 2;
     */
    ordered?: boolean;
    /**
     * @generated from protobuf field: optional int32 max_packet_life_time = 3;
     */
    maxPacketLifeTime?: number;
    /**
     * @generated from protobuf field: optional int32 max_retransmits = 4;
     */
    maxRetransmits?: number;
    /**
     * @generated from protobuf field: optional string protocol = 6;
     */
    protocol?: string;
}
/**
 * @generated from protobuf enum com.wiredprotocol.websocket.webrtc.signaling.TransportType
 */
export enum TransportType {
    /**
     * @generated from protobuf enum value: CONSUMER = 0;
     */
    CONSUMER = 0,
    /**
     * @generated from protobuf enum value: PRODUCER = 1;
     */
    PRODUCER = 1
}
// @generated message type with reflection information, may provide speed optimized methods
class DtlsParameters$Type extends MessageType<DtlsParameters> {
    constructor() {
        super("com.wiredprotocol.websocket.webrtc.signaling.DtlsParameters", [
            { no: 1, name: "role", kind: "enum", T: () => ["com.wiredprotocol.websocket.webrtc.signaling.DtlsParameters.Role", DtlsParameters_Role] },
            { no: 2, name: "fingerprints", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => DtlsParameters_Fingerprint }
        ]);
    }
    create(value?: PartialMessage<DtlsParameters>): DtlsParameters {
        const message = { role: 0, fingerprints: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DtlsParameters>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DtlsParameters): DtlsParameters {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* com.wiredprotocol.websocket.webrtc.signaling.DtlsParameters.Role role */ 1:
                    message.role = reader.int32();
                    break;
                case /* repeated com.wiredprotocol.websocket.webrtc.signaling.DtlsParameters.Fingerprint fingerprints */ 2:
                    message.fingerprints.push(DtlsParameters_Fingerprint.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DtlsParameters, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* com.wiredprotocol.websocket.webrtc.signaling.DtlsParameters.Role role = 1; */
        if (message.role !== 0)
            writer.tag(1, WireType.Varint).int32(message.role);
        /* repeated com.wiredprotocol.websocket.webrtc.signaling.DtlsParameters.Fingerprint fingerprints = 2; */
        for (let i = 0; i < message.fingerprints.length; i++)
            DtlsParameters_Fingerprint.internalBinaryWrite(message.fingerprints[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.wiredprotocol.websocket.webrtc.signaling.DtlsParameters
 */
export const DtlsParameters = new DtlsParameters$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DtlsParameters_Fingerprint$Type extends MessageType<DtlsParameters_Fingerprint> {
    constructor() {
        super("com.wiredprotocol.websocket.webrtc.signaling.DtlsParameters.Fingerprint", [
            { no: 1, name: "algorithm", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "value", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DtlsParameters_Fingerprint>): DtlsParameters_Fingerprint {
        const message = { algorithm: "", value: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DtlsParameters_Fingerprint>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DtlsParameters_Fingerprint): DtlsParameters_Fingerprint {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string algorithm */ 1:
                    message.algorithm = reader.string();
                    break;
                case /* string value */ 2:
                    message.value = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DtlsParameters_Fingerprint, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string algorithm = 1; */
        if (message.algorithm !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.algorithm);
        /* string value = 2; */
        if (message.value !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.value);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.wiredprotocol.websocket.webrtc.signaling.DtlsParameters.Fingerprint
 */
export const DtlsParameters_Fingerprint = new DtlsParameters_Fingerprint$Type();
// @generated message type with reflection information, may provide speed optimized methods
class IceCandidate$Type extends MessageType<IceCandidate> {
    constructor() {
        super("com.wiredprotocol.websocket.webrtc.signaling.IceCandidate", [
            { no: 1, name: "foundation", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "priority", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "ip", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "port", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "protocol", kind: "enum", T: () => ["com.wiredprotocol.websocket.webrtc.signaling.IceCandidate.Protocol", IceCandidate_Protocol] },
            { no: 6, name: "type", kind: "enum", T: () => ["com.wiredprotocol.websocket.webrtc.signaling.IceCandidate.Type", IceCandidate_Type] },
            { no: 7, name: "tcp_type", kind: "enum", opt: true, T: () => ["com.wiredprotocol.websocket.webrtc.signaling.IceCandidate.TcpType", IceCandidate_TcpType] }
        ]);
    }
    create(value?: PartialMessage<IceCandidate>): IceCandidate {
        const message = { foundation: "", priority: 0, ip: "", port: 0, protocol: 0, type: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<IceCandidate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: IceCandidate): IceCandidate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string foundation */ 1:
                    message.foundation = reader.string();
                    break;
                case /* int32 priority */ 2:
                    message.priority = reader.int32();
                    break;
                case /* string ip */ 3:
                    message.ip = reader.string();
                    break;
                case /* int32 port */ 4:
                    message.port = reader.int32();
                    break;
                case /* com.wiredprotocol.websocket.webrtc.signaling.IceCandidate.Protocol protocol */ 5:
                    message.protocol = reader.int32();
                    break;
                case /* com.wiredprotocol.websocket.webrtc.signaling.IceCandidate.Type type */ 6:
                    message.type = reader.int32();
                    break;
                case /* optional com.wiredprotocol.websocket.webrtc.signaling.IceCandidate.TcpType tcp_type */ 7:
                    message.tcpType = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: IceCandidate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string foundation = 1; */
        if (message.foundation !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.foundation);
        /* int32 priority = 2; */
        if (message.priority !== 0)
            writer.tag(2, WireType.Varint).int32(message.priority);
        /* string ip = 3; */
        if (message.ip !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.ip);
        /* int32 port = 4; */
        if (message.port !== 0)
            writer.tag(4, WireType.Varint).int32(message.port);
        /* com.wiredprotocol.websocket.webrtc.signaling.IceCandidate.Protocol protocol = 5; */
        if (message.protocol !== 0)
            writer.tag(5, WireType.Varint).int32(message.protocol);
        /* com.wiredprotocol.websocket.webrtc.signaling.IceCandidate.Type type = 6; */
        if (message.type !== 0)
            writer.tag(6, WireType.Varint).int32(message.type);
        /* optional com.wiredprotocol.websocket.webrtc.signaling.IceCandidate.TcpType tcp_type = 7; */
        if (message.tcpType !== undefined)
            writer.tag(7, WireType.Varint).int32(message.tcpType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.wiredprotocol.websocket.webrtc.signaling.IceCandidate
 */
export const IceCandidate = new IceCandidate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RtpCapabilities$Type extends MessageType<RtpCapabilities> {
    constructor() {
        super("com.wiredprotocol.websocket.webrtc.signaling.RtpCapabilities", [
            { no: 1, name: "codecs", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => RtpCapabilities_Codec },
            { no: 2, name: "header_extensions", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => RtpCapabilities_HeaderExtension }
        ]);
    }
    create(value?: PartialMessage<RtpCapabilities>): RtpCapabilities {
        const message = { codecs: [], headerExtensions: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<RtpCapabilities>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RtpCapabilities): RtpCapabilities {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated com.wiredprotocol.websocket.webrtc.signaling.RtpCapabilities.Codec codecs */ 1:
                    message.codecs.push(RtpCapabilities_Codec.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated com.wiredprotocol.websocket.webrtc.signaling.RtpCapabilities.HeaderExtension header_extensions */ 2:
                    message.headerExtensions.push(RtpCapabilities_HeaderExtension.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RtpCapabilities, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated com.wiredprotocol.websocket.webrtc.signaling.RtpCapabilities.Codec codecs = 1; */
        for (let i = 0; i < message.codecs.length; i++)
            RtpCapabilities_Codec.internalBinaryWrite(message.codecs[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated com.wiredprotocol.websocket.webrtc.signaling.RtpCapabilities.HeaderExtension header_extensions = 2; */
        for (let i = 0; i < message.headerExtensions.length; i++)
            RtpCapabilities_HeaderExtension.internalBinaryWrite(message.headerExtensions[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.wiredprotocol.websocket.webrtc.signaling.RtpCapabilities
 */
export const RtpCapabilities = new RtpCapabilities$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RtpCapabilities_Codec$Type extends MessageType<RtpCapabilities_Codec> {
    constructor() {
        super("com.wiredprotocol.websocket.webrtc.signaling.RtpCapabilities.Codec", [
            { no: 1, name: "kind", kind: "enum", T: () => ["com.wiredprotocol.websocket.webrtc.signaling.RtpCapabilities.Kind", RtpCapabilities_Kind] },
            { no: 2, name: "mime_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "clock_rate", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "channels", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "rtcp_feedback", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => RtpCapabilities_Codec_RtcpFeedback }
        ]);
    }
    create(value?: PartialMessage<RtpCapabilities_Codec>): RtpCapabilities_Codec {
        const message = { kind: 0, mimeType: "", clockRate: 0, rtcpFeedback: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<RtpCapabilities_Codec>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RtpCapabilities_Codec): RtpCapabilities_Codec {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* com.wiredprotocol.websocket.webrtc.signaling.RtpCapabilities.Kind kind */ 1:
                    message.kind = reader.int32();
                    break;
                case /* string mime_type */ 2:
                    message.mimeType = reader.string();
                    break;
                case /* int32 clock_rate */ 3:
                    message.clockRate = reader.int32();
                    break;
                case /* optional int32 channels */ 4:
                    message.channels = reader.int32();
                    break;
                case /* repeated com.wiredprotocol.websocket.webrtc.signaling.RtpCapabilities.Codec.RtcpFeedback rtcp_feedback */ 5:
                    message.rtcpFeedback.push(RtpCapabilities_Codec_RtcpFeedback.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RtpCapabilities_Codec, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* com.wiredprotocol.websocket.webrtc.signaling.RtpCapabilities.Kind kind = 1; */
        if (message.kind !== 0)
            writer.tag(1, WireType.Varint).int32(message.kind);
        /* string mime_type = 2; */
        if (message.mimeType !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.mimeType);
        /* int32 clock_rate = 3; */
        if (message.clockRate !== 0)
            writer.tag(3, WireType.Varint).int32(message.clockRate);
        /* optional int32 channels = 4; */
        if (message.channels !== undefined)
            writer.tag(4, WireType.Varint).int32(message.channels);
        /* repeated com.wiredprotocol.websocket.webrtc.signaling.RtpCapabilities.Codec.RtcpFeedback rtcp_feedback = 5; */
        for (let i = 0; i < message.rtcpFeedback.length; i++)
            RtpCapabilities_Codec_RtcpFeedback.internalBinaryWrite(message.rtcpFeedback[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.wiredprotocol.websocket.webrtc.signaling.RtpCapabilities.Codec
 */
export const RtpCapabilities_Codec = new RtpCapabilities_Codec$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RtpCapabilities_Codec_RtcpFeedback$Type extends MessageType<RtpCapabilities_Codec_RtcpFeedback> {
    constructor() {
        super("com.wiredprotocol.websocket.webrtc.signaling.RtpCapabilities.Codec.RtcpFeedback", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "parameter", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<RtpCapabilities_Codec_RtcpFeedback>): RtpCapabilities_Codec_RtcpFeedback {
        const message = { type: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<RtpCapabilities_Codec_RtcpFeedback>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RtpCapabilities_Codec_RtcpFeedback): RtpCapabilities_Codec_RtcpFeedback {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                case /* optional string parameter */ 2:
                    message.parameter = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RtpCapabilities_Codec_RtcpFeedback, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.type);
        /* optional string parameter = 2; */
        if (message.parameter !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.parameter);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.wiredprotocol.websocket.webrtc.signaling.RtpCapabilities.Codec.RtcpFeedback
 */
export const RtpCapabilities_Codec_RtcpFeedback = new RtpCapabilities_Codec_RtcpFeedback$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RtpCapabilities_HeaderExtension$Type extends MessageType<RtpCapabilities_HeaderExtension> {
    constructor() {
        super("com.wiredprotocol.websocket.webrtc.signaling.RtpCapabilities.HeaderExtension", [
            { no: 1, name: "uri", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "kind", kind: "enum", T: () => ["com.wiredprotocol.websocket.webrtc.signaling.RtpCapabilities.Kind", RtpCapabilities_Kind] },
            { no: 3, name: "preferred_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "preferred_encrypt", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "direction", kind: "enum", opt: true, T: () => ["com.wiredprotocol.websocket.webrtc.signaling.RtpCapabilities.HeaderExtension.Direction", RtpCapabilities_HeaderExtension_Direction] }
        ]);
    }
    create(value?: PartialMessage<RtpCapabilities_HeaderExtension>): RtpCapabilities_HeaderExtension {
        const message = { uri: "", kind: 0, preferredId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<RtpCapabilities_HeaderExtension>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RtpCapabilities_HeaderExtension): RtpCapabilities_HeaderExtension {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string uri */ 1:
                    message.uri = reader.string();
                    break;
                case /* com.wiredprotocol.websocket.webrtc.signaling.RtpCapabilities.Kind kind */ 2:
                    message.kind = reader.int32();
                    break;
                case /* int32 preferred_id */ 3:
                    message.preferredId = reader.int32();
                    break;
                case /* optional bool preferred_encrypt */ 4:
                    message.preferredEncrypt = reader.bool();
                    break;
                case /* optional com.wiredprotocol.websocket.webrtc.signaling.RtpCapabilities.HeaderExtension.Direction direction */ 5:
                    message.direction = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RtpCapabilities_HeaderExtension, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string uri = 1; */
        if (message.uri !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.uri);
        /* com.wiredprotocol.websocket.webrtc.signaling.RtpCapabilities.Kind kind = 2; */
        if (message.kind !== 0)
            writer.tag(2, WireType.Varint).int32(message.kind);
        /* int32 preferred_id = 3; */
        if (message.preferredId !== 0)
            writer.tag(3, WireType.Varint).int32(message.preferredId);
        /* optional bool preferred_encrypt = 4; */
        if (message.preferredEncrypt !== undefined)
            writer.tag(4, WireType.Varint).bool(message.preferredEncrypt);
        /* optional com.wiredprotocol.websocket.webrtc.signaling.RtpCapabilities.HeaderExtension.Direction direction = 5; */
        if (message.direction !== undefined)
            writer.tag(5, WireType.Varint).int32(message.direction);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.wiredprotocol.websocket.webrtc.signaling.RtpCapabilities.HeaderExtension
 */
export const RtpCapabilities_HeaderExtension = new RtpCapabilities_HeaderExtension$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RtpParameters$Type extends MessageType<RtpParameters> {
    constructor() {
        super("com.wiredprotocol.websocket.webrtc.signaling.RtpParameters", [
            { no: 1, name: "codecs", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => RtpParameters_Codec },
            { no: 2, name: "header_extensions", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => RtpParameters_HeaderExtension }
        ]);
    }
    create(value?: PartialMessage<RtpParameters>): RtpParameters {
        const message = { codecs: [], headerExtensions: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<RtpParameters>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RtpParameters): RtpParameters {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated com.wiredprotocol.websocket.webrtc.signaling.RtpParameters.Codec codecs */ 1:
                    message.codecs.push(RtpParameters_Codec.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated com.wiredprotocol.websocket.webrtc.signaling.RtpParameters.HeaderExtension header_extensions */ 2:
                    message.headerExtensions.push(RtpParameters_HeaderExtension.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RtpParameters, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated com.wiredprotocol.websocket.webrtc.signaling.RtpParameters.Codec codecs = 1; */
        for (let i = 0; i < message.codecs.length; i++)
            RtpParameters_Codec.internalBinaryWrite(message.codecs[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated com.wiredprotocol.websocket.webrtc.signaling.RtpParameters.HeaderExtension header_extensions = 2; */
        for (let i = 0; i < message.headerExtensions.length; i++)
            RtpParameters_HeaderExtension.internalBinaryWrite(message.headerExtensions[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.wiredprotocol.websocket.webrtc.signaling.RtpParameters
 */
export const RtpParameters = new RtpParameters$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RtpParameters_Codec$Type extends MessageType<RtpParameters_Codec> {
    constructor() {
        super("com.wiredprotocol.websocket.webrtc.signaling.RtpParameters.Codec", [
            { no: 1, name: "mime_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "payload_type", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "clock_rate", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "channels", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<RtpParameters_Codec>): RtpParameters_Codec {
        const message = { mimeType: "", payloadType: 0, clockRate: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<RtpParameters_Codec>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RtpParameters_Codec): RtpParameters_Codec {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string mime_type */ 1:
                    message.mimeType = reader.string();
                    break;
                case /* int32 payload_type */ 2:
                    message.payloadType = reader.int32();
                    break;
                case /* int32 clock_rate */ 3:
                    message.clockRate = reader.int32();
                    break;
                case /* optional int32 channels */ 4:
                    message.channels = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RtpParameters_Codec, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string mime_type = 1; */
        if (message.mimeType !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.mimeType);
        /* int32 payload_type = 2; */
        if (message.payloadType !== 0)
            writer.tag(2, WireType.Varint).int32(message.payloadType);
        /* int32 clock_rate = 3; */
        if (message.clockRate !== 0)
            writer.tag(3, WireType.Varint).int32(message.clockRate);
        /* optional int32 channels = 4; */
        if (message.channels !== undefined)
            writer.tag(4, WireType.Varint).int32(message.channels);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.wiredprotocol.websocket.webrtc.signaling.RtpParameters.Codec
 */
export const RtpParameters_Codec = new RtpParameters_Codec$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RtpParameters_HeaderExtension$Type extends MessageType<RtpParameters_HeaderExtension> {
    constructor() {
        super("com.wiredprotocol.websocket.webrtc.signaling.RtpParameters.HeaderExtension", [
            { no: 1, name: "uri", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "id", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<RtpParameters_HeaderExtension>): RtpParameters_HeaderExtension {
        const message = { uri: "", id: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<RtpParameters_HeaderExtension>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RtpParameters_HeaderExtension): RtpParameters_HeaderExtension {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string uri */ 1:
                    message.uri = reader.string();
                    break;
                case /* int32 id */ 2:
                    message.id = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RtpParameters_HeaderExtension, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string uri = 1; */
        if (message.uri !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.uri);
        /* int32 id = 2; */
        if (message.id !== 0)
            writer.tag(2, WireType.Varint).int32(message.id);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.wiredprotocol.websocket.webrtc.signaling.RtpParameters.HeaderExtension
 */
export const RtpParameters_HeaderExtension = new RtpParameters_HeaderExtension$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SctpParameters$Type extends MessageType<SctpParameters> {
    constructor() {
        super("com.wiredprotocol.websocket.webrtc.signaling.SctpParameters", [
            { no: 1, name: "port", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "max_message_size", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "max_retransmits", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "negotiated", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "stream_reset", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "partial_reliability", kind: "message", T: () => SctpParameters_PartialReliability }
        ]);
    }
    create(value?: PartialMessage<SctpParameters>): SctpParameters {
        const message = { port: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SctpParameters>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SctpParameters): SctpParameters {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 port */ 1:
                    message.port = reader.int32();
                    break;
                case /* optional int32 max_message_size */ 2:
                    message.maxMessageSize = reader.int32();
                    break;
                case /* optional int32 max_retransmits */ 3:
                    message.maxRetransmits = reader.int32();
                    break;
                case /* optional bool negotiated */ 4:
                    message.negotiated = reader.bool();
                    break;
                case /* optional bool stream_reset */ 5:
                    message.streamReset = reader.bool();
                    break;
                case /* optional com.wiredprotocol.websocket.webrtc.signaling.SctpParameters.PartialReliability partial_reliability */ 6:
                    message.partialReliability = SctpParameters_PartialReliability.internalBinaryRead(reader, reader.uint32(), options, message.partialReliability);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SctpParameters, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 port = 1; */
        if (message.port !== 0)
            writer.tag(1, WireType.Varint).int32(message.port);
        /* optional int32 max_message_size = 2; */
        if (message.maxMessageSize !== undefined)
            writer.tag(2, WireType.Varint).int32(message.maxMessageSize);
        /* optional int32 max_retransmits = 3; */
        if (message.maxRetransmits !== undefined)
            writer.tag(3, WireType.Varint).int32(message.maxRetransmits);
        /* optional bool negotiated = 4; */
        if (message.negotiated !== undefined)
            writer.tag(4, WireType.Varint).bool(message.negotiated);
        /* optional bool stream_reset = 5; */
        if (message.streamReset !== undefined)
            writer.tag(5, WireType.Varint).bool(message.streamReset);
        /* optional com.wiredprotocol.websocket.webrtc.signaling.SctpParameters.PartialReliability partial_reliability = 6; */
        if (message.partialReliability)
            SctpParameters_PartialReliability.internalBinaryWrite(message.partialReliability, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.wiredprotocol.websocket.webrtc.signaling.SctpParameters
 */
export const SctpParameters = new SctpParameters$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SctpParameters_PartialReliability$Type extends MessageType<SctpParameters_PartialReliability> {
    constructor() {
        super("com.wiredprotocol.websocket.webrtc.signaling.SctpParameters.PartialReliability", [
            { no: 1, name: "allowed", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "max_retransmits", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "max_packet_life_time", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<SctpParameters_PartialReliability>): SctpParameters_PartialReliability {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SctpParameters_PartialReliability>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SctpParameters_PartialReliability): SctpParameters_PartialReliability {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional bool allowed */ 1:
                    message.allowed = reader.bool();
                    break;
                case /* optional int32 max_retransmits */ 2:
                    message.maxRetransmits = reader.int32();
                    break;
                case /* optional int32 max_packet_life_time */ 3:
                    message.maxPacketLifeTime = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SctpParameters_PartialReliability, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional bool allowed = 1; */
        if (message.allowed !== undefined)
            writer.tag(1, WireType.Varint).bool(message.allowed);
        /* optional int32 max_retransmits = 2; */
        if (message.maxRetransmits !== undefined)
            writer.tag(2, WireType.Varint).int32(message.maxRetransmits);
        /* optional int32 max_packet_life_time = 3; */
        if (message.maxPacketLifeTime !== undefined)
            writer.tag(3, WireType.Varint).int32(message.maxPacketLifeTime);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.wiredprotocol.websocket.webrtc.signaling.SctpParameters.PartialReliability
 */
export const SctpParameters_PartialReliability = new SctpParameters_PartialReliability$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SctpStreamParameters$Type extends MessageType<SctpStreamParameters> {
    constructor() {
        super("com.wiredprotocol.websocket.webrtc.signaling.SctpStreamParameters", [
            { no: 1, name: "stream_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "ordered", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "max_packet_life_time", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "max_retransmits", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "protocol", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SctpStreamParameters>): SctpStreamParameters {
        const message = { streamId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SctpStreamParameters>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SctpStreamParameters): SctpStreamParameters {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 stream_id */ 1:
                    message.streamId = reader.int32();
                    break;
                case /* optional bool ordered */ 2:
                    message.ordered = reader.bool();
                    break;
                case /* optional int32 max_packet_life_time */ 3:
                    message.maxPacketLifeTime = reader.int32();
                    break;
                case /* optional int32 max_retransmits */ 4:
                    message.maxRetransmits = reader.int32();
                    break;
                case /* optional string protocol */ 6:
                    message.protocol = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SctpStreamParameters, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 stream_id = 1; */
        if (message.streamId !== 0)
            writer.tag(1, WireType.Varint).int32(message.streamId);
        /* optional bool ordered = 2; */
        if (message.ordered !== undefined)
            writer.tag(2, WireType.Varint).bool(message.ordered);
        /* optional int32 max_packet_life_time = 3; */
        if (message.maxPacketLifeTime !== undefined)
            writer.tag(3, WireType.Varint).int32(message.maxPacketLifeTime);
        /* optional int32 max_retransmits = 4; */
        if (message.maxRetransmits !== undefined)
            writer.tag(4, WireType.Varint).int32(message.maxRetransmits);
        /* optional string protocol = 6; */
        if (message.protocol !== undefined)
            writer.tag(6, WireType.LengthDelimited).string(message.protocol);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.wiredprotocol.websocket.webrtc.signaling.SctpStreamParameters
 */
export const SctpStreamParameters = new SctpStreamParameters$Type();
